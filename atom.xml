<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>PHP101</title>
  
  <subtitle>~if you fail to plan，you plan to fail~</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.php101.cn/"/>
  <updated>2020-11-25T18:50:02.288Z</updated>
  <id>http://www.php101.cn/</id>
  
  <author>
    <name>tudouya</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>漏洞及渗透练习平台汇总</title>
    <link href="http://www.php101.cn/2019/08/23/lou-dong-ji-shen-tou-lian-xi-ping-tai-hui-zong.html"/>
    <id>http://www.php101.cn/2019/08/23/lou-dong-ji-shen-tou-lian-xi-ping-tai-hui-zong.html</id>
    <published>2019-08-23T06:46:24.000Z</published>
    <updated>2020-11-25T18:50:02.288Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>很多时候，做安全工具也好，给朋友演示一些安全漏洞原理也好，都需要一些演示环境。特别是现在安全法律法规越来越严格，不能进行未授权的渗透测试，所以更需要自己搭建一些漏洞环境来进行技术研究，本文主要搜集一些开源的漏洞环境，方便以后使用。</p><h2 id="漏洞环境-靶机"><a href="#漏洞环境-靶机" class="headerlink" title="漏洞环境(靶机)"></a>漏洞环境(靶机)</h2><h3 id="hackthebox（HTB）"><a href="#hackthebox（HTB）" class="headerlink" title="hackthebox（HTB）"></a>hackthebox（HTB）</h3><p>项目地址: <a href="https://www.hackthebox.eu/" target="_blank" rel="noopener">https://www.hackthebox.eu/</a></p><h3 id="WebGoat"><a href="#WebGoat" class="headerlink" title="WebGoat"></a>WebGoat</h3><p>项目地址: <a href="https://webgoat.github.io/WebGoat/" target="_blank" rel="noopener">https://webgoat.github.io/WebGoat/</a></p><h3 id="WebGoat-Legacy"><a href="#WebGoat-Legacy" class="headerlink" title="WebGoat-Legacy"></a>WebGoat-Legacy</h3><p>项目地址: <a href="https://github.com/WebGoat/WebGoat-Legacy" target="_blank" rel="noopener">https://github.com/WebGoat/WebGoat-Legacy</a></p><h3 id="DVWA"><a href="#DVWA" class="headerlink" title="DVWA"></a>DVWA</h3><p>项目地址: <a href="https://github.com/RandomStorm/DVWA" target="_blank" rel="noopener">https://github.com/RandomStorm/DVWA</a></p><h3 id="sqli-labs"><a href="#sqli-labs" class="headerlink" title="sqli-labs"></a>sqli-labs</h3><p>项目地址: <a href="https://github.com/Audi-1/sqli-labs" target="_blank" rel="noopener">https://github.com/Audi-1/sqli-labs</a></p><h3 id="vulnhub"><a href="#vulnhub" class="headerlink" title="vulnhub"></a>vulnhub</h3><p>项目地址: <a href="https://www.vulnhub.com/" target="_blank" rel="noopener">https://www.vulnhub.com/</a></p><h3 id="pentesterlab"><a href="#pentesterlab" class="headerlink" title="pentesterlab"></a>pentesterlab</h3><p>项目地址: <a href="https://pentesterlab.com/" target="_blank" rel="noopener">https://pentesterlab.com/</a></p><h3 id="vulnerable-node"><a href="#vulnerable-node" class="headerlink" title="vulnerable-node"></a>vulnerable-node</h3><p>项目地址: <a href="https://github.com/cr0hn/vulnerable-node" target="_blank" rel="noopener">https://github.com/cr0hn/vulnerable-node</a></p><h3 id="ZVulDrill（china）"><a href="#ZVulDrill（china）" class="headerlink" title="ZVulDrill（china）"></a>ZVulDrill（china）</h3><p>项目地址: <a href="https://github.com/710leo/ZVulDrill" target="_blank" rel="noopener">https://github.com/710leo/ZVulDrill</a></p><h3 id="VulApps（china）"><a href="#VulApps（china）" class="headerlink" title="VulApps（china）"></a>VulApps（china）</h3><p>项目地址: <a href="https://github.com/Medicean/VulApps" target="_blank" rel="noopener">https://github.com/Medicean/VulApps</a></p><h3 id="SEED-labs（美国雪城大学）"><a href="#SEED-labs（美国雪城大学）" class="headerlink" title="SEED labs（美国雪城大学）"></a>SEED labs（美国雪城大学）</h3><p>项目地址: <a href="https://seedsecuritylabs.org/index.html" target="_blank" rel="noopener">https://seedsecuritylabs.org</a>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;很多时候，做安全工具也好，给朋友演示一些安全漏洞原理也好，都需要一些演示环境。特别是现在安全法律法规越来越严格，不能进行未授权的渗透测试，所
      
    
    </summary>
    
      <category term="Web安全" scheme="http://www.php101.cn/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>Python类方法装饰器</title>
    <link href="http://www.php101.cn/2019/05/13/python-lei-fang-fa-zhuang-shi-qi.html"/>
    <id>http://www.php101.cn/2019/05/13/python-lei-fang-fa-zhuang-shi-qi.html</id>
    <published>2019-05-13T02:24:25.000Z</published>
    <updated>2020-11-25T18:31:44.979Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在Python中，装饰器是随处可见的，并且装饰器也是很有用的一种语法糖。</p><p>本篇文章主要介绍Python类中常见的几个内建装饰器。</p><h2 id="property装饰器"><a href="#property装饰器" class="headerlink" title="@property装饰器"></a>@property装饰器</h2><p>在面向对象中，为类的属性创建<code>getters</code>和<code>setters</code>通常被认为是最佳实践。许多语言允许通过不同的方法实现<code>getters</code>和<code>setters</code>，或许是通过使用函数，或许是通过语言特有的<code>get</code>和<code>set</code>构造函数。</p><p>在Python中，通过使用<code>@property</code>装饰器来实现<code>getters</code>和<code>setters</code>。</p><h3 id="property-函数"><a href="#property-函数" class="headerlink" title="property()函数"></a>property()函数</h3><p>除了<code>@property</code>装饰器，<code>property()</code>函数也可以在Python中是<code>getters</code>和<code>setters</code>。</p><p>下面定义了一个包含<code>getter</code>和<code>setter</code>方法的类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Persone:</span><br><span class="line">    def __init__(self, name=&apos;Jim Green&apos;):</span><br><span class="line">        self.__name = name</span><br><span class="line"></span><br><span class="line">    def getname(self):</span><br><span class="line">        return self.__name</span><br><span class="line"></span><br><span class="line">    def setname(self, name):</span><br><span class="line">        self.__name = name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">person = Persone()</span><br><span class="line">print(person.getname())</span><br><span class="line"></span><br><span class="line">person.setname(&apos;David&apos;)</span><br><span class="line">print(person.getname())</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line"></span><br><span class="line">Jim Green</span><br><span class="line">David</span><br></pre></td></tr></table></figure><p>从输出可以看出，<code>getname()</code>方法返回了<code>__name</code>属性的值，<code>setname()</code>方法设置了<code>__name</code>属性的值。但是，如果在修改和获取<code>__name</code>属性的时候，能隐式的调用<code>setter</code>和<code>getter</code>方法，就会方便很多。在Python中，提供了<code>propterty()</code>函数达到这种目的。</p><p>Python中<code>property()</code>方法提供了一个访问实例属性的接口，<code>property()</code>方法将<code>get</code>, ‘set’, <code>delete</code>方法作为参数，返回一个<code>属性</code>(property)类的对象。</p><p>下面为类增加一个<code>property()</code>方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Persone:</span><br><span class="line">    def __init__(self, name=&apos;Jim Green&apos;):</span><br><span class="line">        self.__name = name</span><br><span class="line"></span><br><span class="line">    def getname(self):</span><br><span class="line">        print(&apos;getname()...called&apos;)</span><br><span class="line">        return self.__name</span><br><span class="line"></span><br><span class="line">    def setname(self, name):</span><br><span class="line">        print(&apos;setname()...called&apos;)</span><br><span class="line">        self.__name = name</span><br><span class="line"></span><br><span class="line">    name = property(getname, setname)</span><br></pre></td></tr></table></figure><p>在上面的例子中，<code>property(getname, setname)</code>返回了一个属性对象，并赋值给了<code>name</code>。<code>name</code>属性隐藏了对象的私有属性<code>__name</code>。<code>name</code>属性可以被直接访问，但是隐式调用了<code>setname()</code>和<code>getname()</code>方法。</p><p>除了<code>getter</code>和<code>setter</code>，还可以为属性设置个<code>del</code>方法，代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Person:</span><br><span class="line">    def __init__(self, name=&apos;Jim Green&apos;):</span><br><span class="line">        self._name = name</span><br><span class="line"></span><br><span class="line">    def getname(self):</span><br><span class="line">        print(&apos;getname()...called&apos;)</span><br><span class="line">        return self._name</span><br><span class="line"></span><br><span class="line">    def setname(self, name):</span><br><span class="line">        print(&apos;setname()...called&apos;)</span><br><span class="line">        self._name = name</span><br><span class="line"></span><br><span class="line">    def delname(self):</span><br><span class="line">        print(&apos;delname()...called&apos;)</span><br><span class="line">        del self._name</span><br><span class="line"></span><br><span class="line">    name = property(getname, setname, delname)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">person = Person(&apos;Hi&apos;)</span><br><span class="line">print(person.name)</span><br><span class="line"></span><br><span class="line">person.name = &apos;David&apos;</span><br><span class="line">print(person.name)</span><br><span class="line"></span><br><span class="line">del person.name</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line"></span><br><span class="line">getname()...called</span><br><span class="line">Hi</span><br><span class="line">setname()...called</span><br><span class="line">getname()...called</span><br><span class="line">David</span><br><span class="line">delname()...called</span><br></pre></td></tr></table></figure><h3 id="property装饰器-1"><a href="#property装饰器-1" class="headerlink" title="@property装饰器"></a>@property装饰器</h3><p>相比<code>property()</code>函数，<code>@property</code>装饰器提供了一种简单的方法来定义<code>getter</code>和<code>setter</code>。</p><p><code>@property</code>装饰器是Python内建的装饰器。</p><p>下面的代码使用了<code>@property</code>装饰器为类定义了<code>getter</code>和<code>setter</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Person:</span><br><span class="line">    def __init__(self, name=&quot;Jim&quot;):</span><br><span class="line">        self.__name = name</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def name(self):</span><br><span class="line">        print(&apos;call name with property()&apos;)</span><br><span class="line">        return self.__name + &apos;Hi&apos;</span><br><span class="line"></span><br><span class="line">    @name.setter</span><br><span class="line">    def name(self, name):</span><br><span class="line">        print(&apos;call setter&apos;)</span><br><span class="line">        self.__name = name</span><br><span class="line"></span><br><span class="line">    @name.deleter</span><br><span class="line">    def name(self):</span><br><span class="line">        print(&apos;call deleter&apos;)</span><br><span class="line">        del self.__name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">person = Person(&apos;Davi&apos;)</span><br><span class="line">print(person.name)</span><br><span class="line"></span><br><span class="line">person.name = &apos;Jim&apos;</span><br><span class="line">print(person.name)</span><br><span class="line"></span><br><span class="line">del person.name</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">call name with property()</span><br><span class="line">Davi Hi</span><br><span class="line">call setter</span><br><span class="line">call name with property()</span><br><span class="line">Jim Hi</span><br><span class="line">call deleter</span><br></pre></td></tr></table></figure><p>使用<code>property()</code>或者<code>@property</code>为类设置属性的好处有以下几点:</p><ul><li>校验: 在设置类内部属性之前，可以对传入的值进行校验，只有当满足条件后，才能设置属性，如果不满足条件，则抛出错误。</li><li>懒加载: 资源可以被延迟加载，只有当真正使用的时候才被加载，可以节省时间和资源。</li><li>抽象: getter和setter可以对类内部数据的真正表示进行抽象，如上面的例子，调用<code>name</code>返回的其实是拼接出来的数据，并不是<code>__name</code>属性真正的值。</li></ul><h2 id="classmethod装饰器"><a href="#classmethod装饰器" class="headerlink" title="@classmethod装饰器"></a>@classmethod装饰器</h2><p><code>@classmethod</code>装饰器可以被用在任何一个类方法上，它允许我们使用类名直接调用方法，而不用先创建一个对象。</p><blockquote><p>被<code>@classmethod</code>装饰器装饰的方法，第一参数不是<code>self</code>, 而是<code>cls</code>, 代表类本身。</p></blockquote><p><code>@classmethod</code>装饰器使用方法如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Person:</span><br><span class="line">    total = 0</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        Person.total = Person.total + 1</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def showTotal(cls):</span><br><span class="line">        print(f&apos;Total: &#123;cls.total&#125;&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">person1 = Person()</span><br><span class="line">Person.showTotal()</span><br><span class="line"></span><br><span class="line">person2 = Person()</span><br><span class="line">Person.showTotal()</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line"></span><br><span class="line">Total: 1</span><br><span class="line">Total: 2</span><br></pre></td></tr></table></figure><blockquote><p>被<code>@classmethod</code>装饰器装饰的方法，除了可以通过类名直接调用，也可以通过对象调用。</p></blockquote><h2 id="staticmethod装饰器"><a href="#staticmethod装饰器" class="headerlink" title="@staticmethod装饰器"></a>@staticmethod装饰器</h2><p><code>@staticmethod</code>同样是Python内建的装饰器，该装饰器在Python类中用来定义静态方法。</p><p>静态方法在被类实例或者类自身调用时，不接受任何参数。</p><p><code>@staticmethod</code>使用方法如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class person:</span><br><span class="line">    @staticmethod</span><br><span class="line">    def greet():</span><br><span class="line">        print(&quot;Hello!&quot;)</span><br></pre></td></tr></table></figure><p>同样的，静态方法同时支持被类名和类实例调用。</p><h2 id="classmethod-vs-staticmethod"><a href="#classmethod-vs-staticmethod" class="headerlink" title="@classmethod vs @staticmethod"></a>@classmethod vs @staticmethod</h2><ul><li>classmethod将<code>cls</code>作为第一个参数，而staticmethod不需要</li><li>classmethod可以访问和修改类状态，staticmethod不能</li><li>通常会使用classmethod创建工厂方法。工厂方法会返回类对象。</li><li>通常会使用staticmethod创建工具函数。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://stackabuse.com/the-python-property-decorator/" target="_blank" rel="noopener">The Python Property Decorator</a></li><li><a href="https://www.machinelearningplus.com/python/python-property/" target="_blank" rel="noopener">Python @Property Explained – How to Use and When? (Full Examples)</a></li><li><a href="https://realpython.com/instance-class-and-static-methods-demystified/#instance-methods" target="_blank" rel="noopener">Python’s Instance, Class, and Static Methods Demystified</a></li><li><a href="https://stackoverflow.com/questions/136097/what-is-the-difference-between-staticmethod-and-classmethod" target="_blank" rel="noopener">What is the difference between @staticmethod and @classmethod?</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;在Python中，装饰器是随处可见的，并且装饰器也是很有用的一种语法糖。&lt;/p&gt;
&lt;p&gt;本篇文章主要介绍Python类中常见的几个内建装饰器
      
    
    </summary>
    
      <category term="python" scheme="http://www.php101.cn/categories/python/"/>
    
    
  </entry>
  
</feed>
