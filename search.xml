<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[漏洞及渗透练习平台汇总]]></title>
    <url>%2F2019%2F08%2F23%2Flou-dong-ji-shen-tou-lian-xi-ping-tai-hui-zong.html</url>
    <content type="text"><![CDATA[概述很多时候，做安全工具也好，给朋友演示一些安全漏洞原理也好，都需要一些演示环境。特别是现在安全法律法规越来越严格，不能进行未授权的渗透测试，所以更需要自己搭建一些漏洞环境来进行技术研究，本文主要搜集一些开源的漏洞环境，方便以后使用。 漏洞环境(靶机)hackthebox（HTB）项目地址: https://www.hackthebox.eu/ WebGoat项目地址: https://webgoat.github.io/WebGoat/ WebGoat-Legacy项目地址: https://github.com/WebGoat/WebGoat-Legacy DVWA项目地址: https://github.com/RandomStorm/DVWA sqli-labs项目地址: https://github.com/Audi-1/sqli-labs vulnhub项目地址: https://www.vulnhub.com/ pentesterlab项目地址: https://pentesterlab.com/ vulnerable-node项目地址: https://github.com/cr0hn/vulnerable-node ZVulDrill（china）项目地址: https://github.com/710leo/ZVulDrill VulApps（china）项目地址: https://github.com/Medicean/VulApps SEED labs（美国雪城大学）项目地址: https://seedsecuritylabs.org]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python类方法装饰器]]></title>
    <url>%2F2019%2F05%2F13%2Fpython-lei-fang-fa-zhuang-shi-qi.html</url>
    <content type="text"><![CDATA[概述在Python中，装饰器是随处可见的，并且装饰器也是很有用的一种语法糖。 本篇文章主要介绍Python类中常见的几个内建装饰器。 @property装饰器在面向对象中，为类的属性创建getters和setters通常被认为是最佳实践。许多语言允许通过不同的方法实现getters和setters，或许是通过使用函数，或许是通过语言特有的get和set构造函数。 在Python中，通过使用@property装饰器来实现getters和setters。 property()函数除了@property装饰器，property()函数也可以在Python中是getters和setters。 下面定义了一个包含getter和setter方法的类。 123456789101112131415161718192021class Persone: def __init__(self, name=&apos;Jim Green&apos;): self.__name = name def getname(self): return self.__name def setname(self, name): self.__name = nameperson = Persone()print(person.getname())person.setname(&apos;David&apos;)print(person.getname())输出:Jim GreenDavid 从输出可以看出，getname()方法返回了__name属性的值，setname()方法设置了__name属性的值。但是，如果在修改和获取__name属性的时候，能隐式的调用setter和getter方法，就会方便很多。在Python中，提供了propterty()函数达到这种目的。 Python中property()方法提供了一个访问实例属性的接口，property()方法将get, ‘set’, delete方法作为参数，返回一个属性(property)类的对象。 下面为类增加一个property()方法: 12345678910111213class Persone: def __init__(self, name=&apos;Jim Green&apos;): self.__name = name def getname(self): print(&apos;getname()...called&apos;) return self.__name def setname(self, name): print(&apos;setname()...called&apos;) self.__name = name name = property(getname, setname) 在上面的例子中，property(getname, setname)返回了一个属性对象，并赋值给了name。name属性隐藏了对象的私有属性__name。name属性可以被直接访问，但是隐式调用了setname()和getname()方法。 除了getter和setter，还可以为属性设置个del方法，代码如下: 1234567891011121314151617181920212223242526272829303132333435class Person: def __init__(self, name=&apos;Jim Green&apos;): self._name = name def getname(self): print(&apos;getname()...called&apos;) return self._name def setname(self, name): print(&apos;setname()...called&apos;) self._name = name def delname(self): print(&apos;delname()...called&apos;) del self._name name = property(getname, setname, delname)person = Person(&apos;Hi&apos;)print(person.name)person.name = &apos;David&apos;print(person.name)del person.name输出:getname()...calledHisetname()...calledgetname()...calledDaviddelname()...called @property装饰器相比property()函数，@property装饰器提供了一种简单的方法来定义getter和setter。 @property装饰器是Python内建的装饰器。 下面的代码使用了@property装饰器为类定义了getter和setter。 1234567891011121314151617181920212223242526272829303132333435class Person: def __init__(self, name=&quot;Jim&quot;): self.__name = name @property def name(self): print(&apos;call name with property()&apos;) return self.__name + &apos;Hi&apos; @name.setter def name(self, name): print(&apos;call setter&apos;) self.__name = name @name.deleter def name(self): print(&apos;call deleter&apos;) del self.__nameperson = Person(&apos;Davi&apos;)print(person.name)person.name = &apos;Jim&apos;print(person.name)del person.name输出:call name with property()Davi Hicall settercall name with property()Jim Hicall deleter 使用property()或者@property为类设置属性的好处有以下几点: 校验: 在设置类内部属性之前，可以对传入的值进行校验，只有当满足条件后，才能设置属性，如果不满足条件，则抛出错误。 懒加载: 资源可以被延迟加载，只有当真正使用的时候才被加载，可以节省时间和资源。 抽象: getter和setter可以对类内部数据的真正表示进行抽象，如上面的例子，调用name返回的其实是拼接出来的数据，并不是__name属性真正的值。 @classmethod装饰器@classmethod装饰器可以被用在任何一个类方法上，它允许我们使用类名直接调用方法，而不用先创建一个对象。 被@classmethod装饰器装饰的方法，第一参数不是self, 而是cls, 代表类本身。 @classmethod装饰器使用方法如下: 123456789101112131415161718192021class Person: total = 0 def __init__(self): Person.total = Person.total + 1 @classmethod def showTotal(cls): print(f&apos;Total: &#123;cls.total&#125;&apos;)person1 = Person()Person.showTotal()person2 = Person()Person.showTotal()输出:Total: 1Total: 2 被@classmethod装饰器装饰的方法，除了可以通过类名直接调用，也可以通过对象调用。 @staticmethod装饰器@staticmethod同样是Python内建的装饰器，该装饰器在Python类中用来定义静态方法。 静态方法在被类实例或者类自身调用时，不接受任何参数。 @staticmethod使用方法如下: 1234class person: @staticmethod def greet(): print(&quot;Hello!&quot;) 同样的，静态方法同时支持被类名和类实例调用。 @classmethod vs @staticmethod classmethod将cls作为第一个参数，而staticmethod不需要 classmethod可以访问和修改类状态，staticmethod不能 通常会使用classmethod创建工厂方法。工厂方法会返回类对象。 通常会使用staticmethod创建工具函数。 参考 The Python Property Decorator Python @Property Explained – How to Use and When? (Full Examples) Python’s Instance, Class, and Static Methods Demystified What is the difference between @staticmethod and @classmethod?]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
</search>
