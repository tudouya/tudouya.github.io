<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[vant-weapp知识点总结]]></title>
    <url>%2F2020%2F02%2F05%2Fvant-weapp-zhi-shi-dian-zong-jie.html</url>
    <content type="text"><![CDATA[概述微信小程序有许多组件库，经过一系列的调研，最终还是决定采用vant-weapp，但是不可避免的遇到了很多坑，把这些坑记录下来，方便以后使用。 表单数据双向绑定在使用vant-weapp的表单组件时，一直获取不到输入的表单数据，究其原因是因为表单组件输入的值并非是双向绑定的。如果要获取表单中输入的值，需要在表单中绑定事件，并在事件中获取输入的值。使用方法: wxml文件: 1&lt;van-field placeholder-style=&quot;font-size: 32rpx;&quot; left-icon=&quot;/static/images/icon-mobile.png&quot; value=&quot;&#123;&#123;mobile&#125;&#125;&quot; placeholder=&quot;请输入手机号&quot; bind:input=&quot;onMobileInput&quot; /&gt; js文件: 123456789101112131415161718Page(&#123; /** * 页面的初始数据 */ data: &#123; mobile: &apos;&apos; &#125;, /** * 获取输入手机号 */ onMobileInput: function (event) &#123; this.setData(&#123; mobile: event.detail &#125;) &#125;&#125; toast组件使用 引入在js文件中引入Toast函数 1import Toast from &apos;../../miniprogram_npm/@vant/weapp/toast/toast&apos; 注意导入的文件路径及导入的文件，导入的文件为toast组件中的toast.js并非index.js 使用占位符在wxml文件中，使用占位符 1&lt;van-toast id=&quot;van-toast&quot; /&gt;]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python:一切皆对象]]></title>
    <url>%2F2019%2F09%2F04%2Fpython-yi-qie-jie-dui-xiang.html</url>
    <content type="text"><![CDATA[概述很多Python书籍和Python教程都会提到Python中一切皆对对象，但是这些教程往往不会深入解释这句话到底什么意思，这篇文章主要讨论下Python中一切皆对象这句话的深层含义。 Python中一切皆对象Dive into Python这本书给了这句话一个很好的解释: 不同的编程语言使用不同的方式定义对象。在某些编程语言中，它意味着所有的对象都必须有方法和属性。在另外一些编程语言中，它意味着所有对象必须可子类化(subclassable)。在Python中，这个定义更松散，它并不需要所有的对象都有属性和方法，也不需要所有的对象都可以子类化。但是，在Python中一切皆对象意味着一切皆是对象，它可以被分配给一个变量，亦可以做为函数参数。 Python中，一切皆是对象，String是对象，Lists是对象，Functions是对象，甚至于Modules都是对象。 对象在Python中，所有对象都有如下特点: 一个唯一的ID (ID是一个整型数字，通过id(x)获得) 一个类型 (通过 type(x)获得) 一些内容 对象的ID不能修改。 对象的类型不能修改。 有些对象允许修改其内容（ID和类型永远不能被修改），这类对象称为可变对象(Mutable)。有些对象不允许修改其内容，这类对象称为不可变对象(Immutable)。 对象类型被一个类型对象(type object)所表示，该类型对象掌握更多该类型对象的信息，如对象占用了多少内存，对象拥有哪些方法。 在CPython 2.2 或者更新的版本中，在某些限制不严格的环境中，可以修改对象的类型。 对象扩展在Python中，对象还可能有如下特点: 0个或多个方法 0个或多个名称 有些对象提供一些允许修改其内容的方法。有些对象仅提供一些允许访问其内容，但不允许修改的方法。有些对象则没有任何方法。 平时所用到的属性赋值和项引用，仅仅是一种语法糖。 命名(names)命名是指我们通常所说的变量名。 这里的命名有一点不同–名称并不是对象的属性，对象本身并不知道自己叫什么名称。 一个对象可以有许多个命名，也可以没有任何命名。 名称存在于命名空间中，如模块命名空间、实例命名空间、函数本地命名空间等。 命名空间是键值对(使用字典实现)的集合。 当我们调用一个函数时，函数的命名空间随着调用函数时传递的参数被初始化。 赋值赋值操作改变的是命名空间，并没有修改对象。 如下示例: 1name = 10 上述代码意味着将name这个名称添加到本地的命名空间中，同时将这个名称指向一个值为10的整型对象。 如果某个名称之前已经存在，赋值操作将替换原来的名称指向。 示例如下: 12name = 10name = 20 上述代码表示，首先将name这个名称添加到本地命名空间中，并将它指向一个值为10的整型对象中。然后，第二次赋值操作，替换了name这个名称的内容，将它指向一个值为20的整型对象中。最初的值为10的整型对象并未被该操作影响。 相反的，如果执行以下操作: 12name = []name.append(1) 上述代码中，首先将name这个名称添加到了本地命名空间中，并将它指向一个值列表对象中，这个操作修改了命名空间。然后，调用了该对象的一个方法，向自身添加一个整型对象，这个操作修改对象本身的内容，但是它并没有影响到命名空间，也没有影响到添加到自身的整型对象。 上述代码中，name.attr、name[index]这些可能的操作仅仅是语法糖。如,name.attr对应__setattr__/__getattr__方法,name[index]对应__setitem__/__getitem__方法。 参考 Python Objects http://www.oznetnerd.com/python-everything-object-first-class-citizens/ Python: Everything is an Object, and Some Objects are Mutable]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[htop详解]]></title>
    <url>%2F2019%2F08%2F28%2Fhtop-xiang-jie.html</url>
    <content type="text"><![CDATA[概述Linux系统自带的top命令是分析Linux系统运行状况的神器，这篇文章主要介绍htop命令，它可以看做是top命令的曾增强版。 htop vs top相比top命令，htop有很多自身的优势，如: top操作繁琐,htop操作简单 htop支持图形界面的鼠标操作 可以横向或纵向滚动浏览进程列表，以便看到所有的进程和完整的命令行 杀进程时不需要输入进程号等 htop安装不同的Linux发行版下，可以使用的对应的包管理工具安装htop,如centos下可以使用如下命令安装: 1yum install htop htop结果详解UptimeUptime显示了系统运行时间，可以通过uptime命令查看相同的信息: 123$ uptime17:28:20 up 3 days, 14:09, 1 user, load average: 0.01, 0.02, 0.05 uptime命令通过读取/proc/uptime文件获取系统运行时间, 12]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Centos7安装PHP 5.6]]></title>
    <url>%2F2019%2F08%2F26%2Fcentos7-an-zhuang-php-5-6.html</url>
    <content type="text"><![CDATA[概述Centos7 目前已经很普及了，但是随着Centos7的PHP版本还是过时的5.4，当前情况下PHP7也已经很流行了，但是有一些开源的PHP CMS 还不支持PHP7 所以还是需要在Centos上安装PHP 5.6，本文主要记录如何在Centos上安装PHP 5.6。 安装步骤安装remi仓库1234567yum install -y epel-releasewget https://rpms.remirepo.net/enterprise/remi-release-7.rpmrpm -ivh remi-release-7.rpmyum update 安装 PHP5.61yum install php56 php56-php php56-php-mysqlnd php56-php-gd php56-php-mcrypt php56-php-mbstring php56-php-xml php56-php-cli 安装 PHP-FPM1yum install php56-php-fpm 启动/关闭/重启 PHP-FPM123systemctl start php56-php-fpmsystemctl stop php56-php-fpmsystemctl restart php56-php-fpm 参考 Install PHP 5.6 on CentOS 7 Server]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[漏洞及渗透练习平台汇总]]></title>
    <url>%2F2019%2F08%2F23%2Flou-dong-ji-shen-tou-lian-xi-ping-tai-hui-zong.html</url>
    <content type="text"><![CDATA[概述很多时候，做安全工具也好，给朋友演示一些安全漏洞原理也好，都需要一些演示环境。特别是现在安全法律法规越来越严格，不能进行未授权的渗透测试，所以更需要自己搭建一些漏洞环境来进行技术研究，本文主要搜集一些开源的漏洞环境，方便以后使用。 漏洞环境(靶机)hackthebox（HTB）项目地址: https://www.hackthebox.eu/ WebGoat项目地址: https://webgoat.github.io/WebGoat/ WebGoat-Legacy项目地址: https://github.com/WebGoat/WebGoat-Legacy DVWA项目地址: https://github.com/RandomStorm/DVWA sqli-labs项目地址: https://github.com/Audi-1/sqli-labs vulnhub项目地址: https://www.vulnhub.com/ pentesterlab项目地址: https://pentesterlab.com/ vulnerable-node项目地址: https://github.com/cr0hn/vulnerable-node ZVulDrill（china）项目地址: https://github.com/710leo/ZVulDrill VulApps（china）项目地址: https://github.com/Medicean/VulApps SEED labs（美国雪城大学）项目地址: https://seedsecuritylabs.org]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开源镜像汇总]]></title>
    <url>%2F2019%2F07%2F12%2Fkai-yuan-jing-xiang-hui-zong.html</url>
    <content type="text"><![CDATA[概述汇总国内常见开源镜像，提高开发效率。 composer镜像 提供商 地址 阿里云 https://developer.aliyun.com/composer]]></content>
      <categories>
        <category>网络资源</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python类方法装饰器]]></title>
    <url>%2F2019%2F05%2F13%2Fpython-lei-fang-fa-zhuang-shi-qi.html</url>
    <content type="text"><![CDATA[概述在Python中，装饰器是随处可见的，并且装饰器也是很有用的一种语法糖。 本篇文章主要介绍Python类中常见的几个内建装饰器。 @property装饰器在面向对象中，为类的属性创建getters和setters通常被认为是最佳实践。许多语言允许通过不同的方法实现getters和setters，或许是通过使用函数，或许是通过语言特有的get和set构造函数。 在Python中，通过使用@property装饰器来实现getters和setters。 property()函数除了@property装饰器，property()函数也可以在Python中是getters和setters。 下面定义了一个包含getter和setter方法的类。 123456789101112131415161718192021class Persone: def __init__(self, name=&apos;Jim Green&apos;): self.__name = name def getname(self): return self.__name def setname(self, name): self.__name = nameperson = Persone()print(person.getname())person.setname(&apos;David&apos;)print(person.getname())输出:Jim GreenDavid 从输出可以看出，getname()方法返回了__name属性的值，setname()方法设置了__name属性的值。但是，如果在修改和获取__name属性的时候，能隐式的调用setter和getter方法，就会方便很多。在Python中，提供了propterty()函数达到这种目的。 Python中property()方法提供了一个访问实例属性的接口，property()方法将get, ‘set’, delete方法作为参数，返回一个属性(property)类的对象。 下面为类增加一个property()方法: 12345678910111213class Persone: def __init__(self, name=&apos;Jim Green&apos;): self.__name = name def getname(self): print(&apos;getname()...called&apos;) return self.__name def setname(self, name): print(&apos;setname()...called&apos;) self.__name = name name = property(getname, setname) 在上面的例子中，property(getname, setname)返回了一个属性对象，并赋值给了name。name属性隐藏了对象的私有属性__name。name属性可以被直接访问，但是隐式调用了setname()和getname()方法。 除了getter和setter，还可以为属性设置个del方法，代码如下: 1234567891011121314151617181920212223242526272829303132333435class Person: def __init__(self, name=&apos;Jim Green&apos;): self._name = name def getname(self): print(&apos;getname()...called&apos;) return self._name def setname(self, name): print(&apos;setname()...called&apos;) self._name = name def delname(self): print(&apos;delname()...called&apos;) del self._name name = property(getname, setname, delname)person = Person(&apos;Hi&apos;)print(person.name)person.name = &apos;David&apos;print(person.name)del person.name输出:getname()...calledHisetname()...calledgetname()...calledDaviddelname()...called @property装饰器相比property()函数，@property装饰器提供了一种简单的方法来定义getter和setter。 @property装饰器是Python内建的装饰器。 下面的代码使用了@property装饰器为类定义了getter和setter。 1234567891011121314151617181920212223242526272829303132333435class Person: def __init__(self, name=&quot;Jim&quot;): self.__name = name @property def name(self): print(&apos;call name with property()&apos;) return self.__name + &apos;Hi&apos; @name.setter def name(self, name): print(&apos;call setter&apos;) self.__name = name @name.deleter def name(self): print(&apos;call deleter&apos;) del self.__nameperson = Person(&apos;Davi&apos;)print(person.name)person.name = &apos;Jim&apos;print(person.name)del person.name输出:call name with property()Davi Hicall settercall name with property()Jim Hicall deleter 使用property()或者@property为类设置属性的好处有以下几点: 校验: 在设置类内部属性之前，可以对传入的值进行校验，只有当满足条件后，才能设置属性，如果不满足条件，则抛出错误。 懒加载: 资源可以被延迟加载，只有当真正使用的时候才被加载，可以节省时间和资源。 抽象: getter和setter可以对类内部数据的真正表示进行抽象，如上面的例子，调用name返回的其实是拼接出来的数据，并不是__name属性真正的值。 @classmethod装饰器@classmethod装饰器可以被用在任何一个类方法上，它允许我们使用类名直接调用方法，而不用先创建一个对象。 被@classmethod装饰器装饰的方法，第一参数不是self, 而是cls, 代表类本身。 @classmethod装饰器使用方法如下: 123456789101112131415161718192021class Person: total = 0 def __init__(self): Person.total = Person.total + 1 @classmethod def showTotal(cls): print(f&apos;Total: &#123;cls.total&#125;&apos;)person1 = Person()Person.showTotal()person2 = Person()Person.showTotal()输出:Total: 1Total: 2 被@classmethod装饰器装饰的方法，除了可以通过类名直接调用，也可以通过对象调用。 @staticmethod装饰器@staticmethod同样是Python内建的装饰器，该装饰器在Python类中用来定义静态方法。 静态方法在被类实例或者类自身调用时，不接受任何参数。 @staticmethod使用方法如下: 1234class person: @staticmethod def greet(): print(&quot;Hello!&quot;) 同样的，静态方法同时支持被类名和类实例调用。 @classmethod vs @staticmethod classmethod将cls作为第一个参数，而staticmethod不需要 classmethod可以访问和修改类状态，staticmethod不能 通常会使用classmethod创建工厂方法。工厂方法会返回类对象。 通常会使用staticmethod创建工具函数。 参考 The Python Property Decorator Python @Property Explained – How to Use and When? (Full Examples) Python’s Instance, Class, and Static Methods Demystified What is the difference between @staticmethod and @classmethod?]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python面向对象总结]]></title>
    <url>%2F2019%2F05%2F10%2Fpython-mian-xiang-dui-xiang-zong-jie.html</url>
    <content type="text"><![CDATA[概述Python 是一门完全面向对象的语言。在 Python 中，一切都是对象。从我们开始使用 Python 时，我们就已经使用了 Python 中的对象和类。Python 程序中的每一个元素都是类的一个实例，如数字、字符串、列表、字典这些元素，都是 Python 内置类对应的一个对象，甚至于使用def关键字定义的一个函数都对应一个function类。 面向对象基础Python 使用class关键字声明一个类。 一个典型的 Python 类主要包含以下成员: 构造函数 (constructor) 实例属性 (Instance Attributes) 类属性 (Class Attributes) 方法 (Class Attributes) 一个类也可以没有任何成员，如下面的Car类就没有任何成员: 123class Car: &apos;&apos;&apos;This is an empty Car Class&apos;&apos;&apos; pass 下面的类则包含了实例属性、类属性、构造函数、方法等成员: 123456789class Car: brand = &apos;BenChi&apos; def __init__(self): self.price = 10000 self.chair = 7 def run(self): print(&apos;Run 100km Per Hour....&apos;) 构造函数在 Python 中，构造函数是实例化一个类对象的时自动被调用的函数，类似于 Java 或 C# 中的构造函数。构造函数必须使用一个特定的名称__init__，并且必须有一个固定的参数self。 Python 类中几乎每一个方法都要将 self 作为第一个参数，self 是调用该方法的对象的引用。其实，第一个参数的名字是任意的，并不一定要叫 self, self 只是一种约定。 注意，注意，注意: __init__方法并不是 Python 类构造函数，关于 Python 类的构造函数其实有很大争议，这里主要是为了介绍面向对象的概念。 下面的例子定义了一个构造函数: 1234567class Car: def __init__(self): print(&apos;Call Constructor......&apos;)car1 = Car()car2 = Car() Python 中构造函数(init)的作用定义了类实例的属性，并对实例属性进行复制。 实例属性实例属性是与类实例绑定的属性，其定义在构造函数(init)中。 下面的例子定义了两个实例属性: 1234class Car: def __init__(self): self.price = 100 self.chair = 7 类属性类属性不同于实例属性，类属性的值被所有实例对象共享。类属性在类级别定义而不是定义在__init__方法中。类属性的访问也不同于实例属性，类属性的访问是通过类名, 也可以通过实例访问。 下面例子定义了一个类属性: 12345class Car: brand = &quot;benchi&quot;print(Car.brand) 通过类名修改类属性通过类名修改类属性，那么该类所有的实例对象对应的类属性都会被修改, 如下: 1234567891011121314151617181920212223242526class Car: brand = &quot;benchi&quot;car1 = Car()car2 = Car()print(&apos;Before Change.............&apos;)print(f&apos;car1 brand is: &#123;car1.brand&#125;&apos;)print(f&apos;car2 brand is: &#123;car2.brand&#125;&apos;)print(&apos;Change Class Attribute By [Class Name]&apos;)Car.brand = &apos;Audi&apos;print(&apos;After Change.............&apos;)print(f&apos;car1 brand is: &#123;car1.brand&#125;&apos;)print(f&apos;car2 brand is: &#123;car2.brand&#125;&apos;)输出:Before Change.............car1 brand is: benchicar2 brand is: benchiChange Class Attribute By [Class Name]After Change.............car1 brand is: Audicar2 brand is: Audi 通过实例对象修改类属性通过实例对象修改类属性，并不会影响其他对象类属性的值，他仅仅影响该实例对象自己类属性的值，如下: 123456789101112131415161718192021222324252627282930class Car: brand = &quot;benchi&quot;car1 = Car()car2 = Car()print(&apos;Before Change.............&apos;)print(f&apos;car1 brand is: &#123;car1.brand&#125;&apos;)print(f&apos;car2 brand is: &#123;car2.brand&#125;&apos;)print(&apos;Change Class Attribute By [Object]&apos;)car1.brand = &apos;Audi&apos;car2.brand = &apos;KaYan&apos;print(&apos;After Change.............&apos;)print(f&apos;car1 brand is: &#123;car1.brand&#125;&apos;)print(f&apos;car2 brand is: &#123;car2.brand&#125;&apos;)print(f&apos;Car brand is: &#123;Car.brand&#125;&apos;)输出:Before Change.............car1 brand is: benchicar2 brand is: benchiChange Class Attribute By [Object]After Change.............car1 brand is: Audicar2 brand is: KaYanCar brand is: benchi 类方法在一个类中，可以定义尽可能多的类方法，一般情况下，类方法的第一个参数都是self。 下面的类就定义了一个类方法: 12345class Car: brand = &quot;benchi&quot; def run(self): print(&apos;Run......&apos;) 面向对象之封装面向对象语言，如Java、C++等，使用public、protected、private等关键字来控制对类资源的访问。 类的private成员仅能在类内部进行访问，其他任何地方都不能访问，包括其子类。 类的protected成员可以在类内部和其子类中访问。 类的public成员可以在任何地方进行访问。 Python没有使用关键字机制来限制对类成员方法和类成员属性的访问，Python规定了一种约定，在类方法或者类成员前加_(下划线)或者__(双下划线)来模拟private或者public访问修饰期的功能。 public成员Python中的所有成员默认都是public属性，可以在任何地方访问。 如下代码: 123456789101112131415161718192021222324class Car: def __init__(self, brand, price): self.brand = brand self.price = price def run(self): print(&apos;Run......&apos;)brand = &apos;Audi&apos;price = 10000car = Car(brand, price)# 访问类属性print(car.brand)print(car.price)# 访问类方法car.run()输出结果:Audi10000Run...... protected成员Python约定，如果类成员前加了单个下划线_, 则类成员为protected成员。 1234567891011121314151617181920212223242526272829class Car: def __init__(self, brand, price): self._brand = brand self._price = price def _run(self): print(&apos;Run......&apos;)brand = &apos;Audi&apos;price = 10000car = Car(brand, price)# 访问protected属性print(car._brand)print(car._price)# 修改protected属性car._price = 20000print(car._price)# 访问类方法car._run()输出结果:Audi1000020000Run...... 使用单下划线的方式将属性声明为protected, 并不能真正起到作用，它仅仅是一种约定。 private成员Python约定，如果类成员前加了双下划线__, 则类成员为private成员。 如下代码: 1234567891011class Car: def __init__(self, brand, price): self._brand = brand self._price = price def __run(self): print(&apos;Run......&apos;)# 访问类方法car._run() # 程序报错，&apos;Car&apos; object has no attribute &apos;_run&apos; 面向对象之继承在面向对象编程中，继承是达到代码重用目的的一种方式。在继承中，子类可以使用其父类的一部分代码。 继承的基本使用下面先创建一个父类, 代码如下: 12345678910111213class Fish: def __init__(self, first_name, last_name=&quot;Fish&quot;, skeleton=&quot;bone&quot;, eyelids=False): self.first_name = first_name self.last_name = last_name self.skeleton = skeleton self.eyelids = eyelids def swim(self): print(&quot;The fish is swimming.&quot;) def swim_backwards(self): print(&quot;The fish can swim backwards.&quot;) 接下来，创建一个没有任何方法和属性的子类，代码如下: 12class Trout(Fish): pass Python类继承的语法是在定义类的时候，传入父类的名字作为参数 由于Trout类继承了Fish类，Trout类就是Fish类的子类，Trout类的对象就可以调用其父类的所有方法，代码如下: 1234567891011121314terry = Trout(&quot;Terry&quot;)print(terry.first_name + &quot; &quot; + terry.last_name)print(terry.skeleton)print(terry.eyelids)terry.swim()terry.swim_backwards()输出:Terry FishboneFalseThe fish is swimming.The fish can swim backwards. 接下来，再创建另一个子类，该子类有自己的方法: 1234class Clownfish(Fish): def live_with_anemone(self): print(&quot;The clownfish is coexisting with sea anemone.&quot;) 创建Clownfish的一个对象，并调用其方法: 1234567891011121314class Clownfish(Fish): def live_with_anemone(self): print(&quot;The clownfish is coexisting with sea anemone.&quot;)casey = Clownfish(&quot;Casey&quot;)print(casey.first_name + &quot; &quot; + casey.last_name)casey.swim()casey.live_with_anemone()输出:Casey FishThe fish is swimming.The clownfish is coexisting with sea anemone. 从输出结果可以看出，Clownfish的对象casey可以调用其父类的swim()方法和__init__()方法，同时可以调用它自身的live_with_anemone()方法。 覆盖父类方法有时候，子类继承了父类的全部方法和属性，但是只想使用其中的一部分方法和属性，当子类定义了和父类一样的方法时，就会覆盖(override)父类的方法。 有一点需要注意的是，尽管子类覆盖了父类的方法，但是并没有产生多余的代码。 下面定义一个覆盖父类__init__()方法和swim_backwards()方法的类: 123456789101112131415161718192021222324class Shark(Fish): def __init__(self, first_name, last_name=&quot;Shark&quot;, skeleton=&quot;cartilage&quot;, eyelids=True): self.first_name = first_name self.last_name = last_name self.skeleton = skeleton self.eyelids = eyelids def swim_backwards(self): print(&quot;The shark cannot swim backwards, but can sink backwards.&quot;)sammy = Shark(&quot;Sammy&quot;)print(sammy.first_name + &quot; &quot; + sammy.last_name)sammy.swim()sammy.swim_backwards()print(sammy.eyelids)print(sammy.skeleton)结果:Sammy SharkThe fish is swimming.The shark cannot swim backwards, but can sink backwards.Truecartilage 从输出结果可以看出，子类成功覆盖了父类的方法。 super()函数如果子类覆盖了父类的方法，同时又想使用父类的方法，可以使用super()函数。 super()函数经常在__init__()方法中被使用。 修改一下上文所提到的Trout类，代码如下: 1234567891011121314151617181920212223class Trout(Fish): def __init__(self, water = &quot;freshwater&quot;): self.water = water super().__init__(self)terry = Trout()terry.first_name = &quot;Terry&quot;print(terry.first_name + &quot; &quot; + terry.last_name)print(terry.eyelids)print(terry.water)terry.swim()输出:Terry FishFalsefreshwaterThe fish is swimming. 从输出结果可以看出，使用super()函数成功调用了父类被子类覆盖的方法。 多重继承多重继承即一个类可以继承多个类。 多重继承基本语法如下: 1234567891011121314class Coral: def community(self): print(&quot;Coral lives in a community.&quot;)class Anemone: def protect_clownfish(self): print(&quot;The anemone is protecting the clownfish.&quot;)class CoralReef(Coral, Anemone): pass 总结本篇文章总结了Python面向对象的基本概念及基本使用方法，弥补自己在Python方面面向对象方法的不足。 参考 Private, protected and public in Python Understanding Class Inheritance in Python 3]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ES6实战]]></title>
    <url>%2F2019%2F03%2F24%2Fes6-shi-zhan.html</url>
    <content type="text"><![CDATA[概述ES6风风风火火的出来很长时间了，从最初的babel插件支持，到vue或者react框架，再到浏览器原生支持。ES6中定义了很多方便实用的特性，但是一直没怎么深入了解，从今天起开始陆续深入平时写代码的过程中，遇到的ES6各种特性。 扩展运算符(spread operator)…使用扩展运算符可以展开数组，对象和字符串。 扩展运算符(…)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中 创建新数组12const a = [1, 2, 3]const b = [...a, 4, 5, 6] // Array(6) [ 1, 2, 3, 4, 5, 6 ] 合并数组12345678// ES5中concat()方法const arr1 = [&quot;a&quot;, &quot;b&quot;]const arr2 = [&quot;c&quot;]const arr3 = [&quot;d&quot;, &quot;e&quot;]const arrAll = arr1.concat(arr2, arr3) // Array(5) [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot; ]// 扩展云算法const arrAll = [...arr1, ...arr2, ...arr3] // Array(5) [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot; ] 创建新数组1234const arr1 = [&quot;a&quot;, &quot;b&quot;]const arr2 = [&quot;c&quot;]const arr3 = [&quot;d&quot;, &quot;e&quot;]const arr4 = [...arr1, ...arr2, ...arr3, &quot;f&quot;, &quot;g&quot;] // Array(7) [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot; ] 创建新对象12345const oldPerson = &#123; user: &quot;tudouya&quot;, password: &quot;123456&quot;&#125;const newPerson = &#123; ...oldPerson &#125; // Object &#123; user: &quot;tudouya&quot;, password: &quot;123456&quot; &#125; 展开字符串12const str = &quot;hello&quot;const arr = [...str] // Array(5) [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Javascript创建对象方式总结]]></title>
    <url>%2F2019%2F02%2F25%2Fjavascript-chuang-jian-dui-xiang-fang-shi-zong-jie.html</url>
    <content type="text"><![CDATA[概述在JavaScript中， 对象向我们提供了一种存储，操作，并在网络中传输数据的方式。同时，把对象当成键值对的集合，给我们带来了一种最常用的创建JavaScript对象的方法。 使用对象字面值(object literal)创建对象在JavaScript中，这是创建对象最简单的方式。语法如下: 1234var person = &#123; firstName: &apos;san&apos;, lastName: &apos;zhang&apos;&#125; 使用new关键字创建对象这种创建对象的方式，类似于在其他面向对象的语言中创建对象，如Java。顺便说一下，从ES6开始，类在JavaScript中是原生存在的，可以通过定义类来创建对象。使用new关键字创建对象，需要一个构造器函数。 使用new关键字创建对象，有如下两种形式: 使用内建的Object构造器函数创建对象: 1var person = new Object() 向对象添加属性: 12person.firtName = &apos;san&apos;person.lastName = &apos;zhang&apos; 不推荐使用这种方式创建对象，因为会涉及到作用域解析，JavaScript会去检测构造器函数是用户创建的还是系统内建的。 使用用户定义的构造器函数使用Object()构造器函数创建对象的问题是每次创建完对象，都需要手工去为对象添加属性。为了避免每次都需要手工为对象添加属性，我们可以创建一个自定义函数。首先，我们创建一个构造器函数，然后使用new关键字创建对象。 123456function Person(firstName, lastName) &#123; this.firstName = firstName this.lastName = lastName&#125;var person = new Person(&quot;san&quot;, &quot;zhang&quot;)var person1 = new Person(&quot;si&quot;, &quot;li&quot;) 在这种创建对象的方式中，new关键字执行了以下步骤: 调用函数 修改this关键字指向，将该函数的this指向一个新对象 将新对象的原型(prototype)绑定到函数的原型 代码说明如下: 12345678// new关键字function Person(name) &#123; this.name = name&#125;var person = new Person(&quot;tudouya&quot;)// 等价代码var person1 = Object.create(Person.prototype) 原型(Prototype)方法创建对象使用原型方法创建对象，代码如下: 123function Person()&#123;&#125;;Person.prototype.name = &quot;tudouya&quot;; 原型和函数结合创建对象代码如下: 123456function Person(name)&#123; this.name = name;&#125; Person.prototype.getName = function()&#123; return this.name&#125; 使用Object.create()方法创建对象使用这种方式创建对象，可以很方便的从一个已经存在的对象创建一个新对象，而不用使用new关键字。 Object.create()方法基于一个已经存在的对象作为新创建对象的原型。 使用Object.create()方法创建对象，只需要记住它需要传入两个参数。第一个参数可以是任意一个对象，该对象作为新创建对象的原型。第二个参数是可选参数，类型是对象，该对象包含向新创建对象添加的属性。 假设有一个班级对象Class: 1var classObj = &#123; className: &quot;一班&quot;, studentNum: 100 &#125; 现在想为这个班级创建一个学生，可以使用如下方式: 12345678var studentObj = Object.create(classObj, &#123; studentName: &#123; value: &quot;小明&quot; &#125;, studentAge: &#123; value: 29 &#125;&#125;) 注意第二个参数的写法 使用Object.assign()方法创建对象假如我们想创建一个拥有一个以上对象的所有属性的新对象，Object.assign()方法可以实现这种目的。 Object.assign()方法用来将一个或多个源对象的所有可枚举的属性拷贝到一个目标对象中。 Object.assign()可以接受任意数量的对象作为参数。第一个参数是他即将创建，并且返回的参数。其余传入的对象参数，被用来将属性复制到新对象中。 假设有如下两个对象: 12var orgObj = &#123; company: &quot;Baidu&quot; &#125;var carObj = &#123; carName: &quot;Kayan&quot; &#125; 现在需要一个在Baidu公司开着Kayan的员工，可以使用如下方式创建对象: 1var employee = Object.assign(&#123;&#125;, carObj, orgObj) singleton(单例)方法创建对象代码如下: 123var person = new function()&#123; this.name = &quot;tudouya&quot;&#125; 使用ES6 class创建对象使用ES6 class创建对象与使用用户定义的函数构造器创建对象方法类似。构造器函数被类替代，因为它遵循ES6规范。 示例如下: 1234567class Person &#123; constructor(firstName, lastName) &#123; this.firstName = firstName this.lastName = lastName &#125;&#125;var person = new Person(&quot;san&quot;, &quot;zhang&quot;) 参考 Different ways of creating an Object in javascript Which way is best for creating an object in JavaScript? Is var necessary before an object property? How to create objects in JavaScript]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
</search>
